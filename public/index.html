<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Redis Subscriber 4</title>
<script src="/socket.io/socket.io.js"></script>
<style>
  body { font-family: monospace; padding: 20px; }
  .channel { margin-bottom: 10px; }
  .controls { margin-bottom: 20px; padding: 15px; border: 1px solid #ccc; }
  input { padding: 5px; font-family: monospace; width: 300px; }
  textarea { padding: 5px; font-family: monospace; width: 100%; min-height: 100px; }
  button { padding: 5px 15px; cursor: pointer; margin-right: 5px; }
  .status { margin-top: 10px; color: green; }
  .section { margin-bottom: 15px; }
  label { display: block; margin-bottom: 5px; font-weight: bold; }
  
  /* Two-column layout */
  .messages-container { display: flex; gap: 20px; }
  .node-values { 
    flex: 1; 
    border: 1px solid #ccc; 
    padding: 10px; 
    max-height: 600px; 
    overflow-y: auto;
  }
  .activity-log { 
    flex: 1; 
    border: 1px solid #ccc; 
    padding: 10px; 
    max-height: 600px; 
    overflow-y: auto;
  }
  .column-header { 
    font-weight: bold; 
    font-size: 16px; 
    margin-bottom: 10px; 
    padding-bottom: 5px; 
    border-bottom: 2px solid #333;
  }
  .node-item {
    margin-bottom: 8px;
    padding: 5px;
    background: #f5f5f5;
    border-left: 3px solid #4CAF50;
  }
  .node-name {
    font-weight: bold;
    color: #333;
  }
  .node-value {
    color: #0066cc;
    margin-left: 10px;
  }
  .edit-button {
    background: #2196F3;
    color: white;
    border: none;
    padding: 3px 10px;
    border-radius: 3px;
    cursor: pointer;
    font-size: 12px;
    margin-top: 5px;
  }
  .edit-button:hover {
    background: #1976D2;
  }
  
  /* Modal styles */
  .modal {
    display: none;
    position: fixed;
    z-index: 1000;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0,0,0,0.4);
  }
  .modal-content {
    background-color: #fefefe;
    margin: 10% auto;
    padding: 20px;
    border: 1px solid #888;
    width: 500px;
    border-radius: 5px;
  }
  .modal-header {
    font-size: 18px;
    font-weight: bold;
    margin-bottom: 15px;
  }
  .modal-body {
    margin-bottom: 15px;
  }
  .modal-footer {
    text-align: right;
  }
  .modal-input {
    width: 100%;
    padding: 8px;
    font-family: monospace;
    font-size: 14px;
    margin-top: 5px;
  }
  .modal-label {
    display: block;
    margin-top: 10px;
    font-weight: bold;
  }
  .btn-primary {
    background: #4CAF50;
    color: white;
    border: none;
    padding: 8px 20px;
    border-radius: 3px;
    cursor: pointer;
  }
  .btn-primary:hover {
    background: #45a049;
  }
  .btn-secondary {
    background: #999;
    color: white;
    border: none;
    padding: 8px 20px;
    border-radius: 3px;
    cursor: pointer;
    margin-right: 10px;
  }
  .btn-secondary:hover {
    background: #777;
  }
  
  /* Tree view styles */
  .tree-container { font-family: monospace; }
  .tree-item { margin-left: 15px; }
  .tree-folder { 
    cursor: pointer; 
    padding: 3px;
    user-select: none;
    display: flex;
    align-items: center;
    gap: 5px;
  }
  .tree-folder:hover { background-color: #e0e0e0; }
  .tree-folder-label {
    flex: 1;
  }
  .tree-folder-add-btn {
    background: #4CAF50;
    color: white;
    border: none;
    padding: 2px 8px;
    border-radius: 3px;
    cursor: pointer;
    font-size: 11px;
    font-weight: bold;
  }
  .tree-folder-add-btn:hover {
    background: #45a049;
  }
  .tree-leaf { 
    cursor: pointer; 
    padding: 3px; 
    color: #0066cc;
  }
  .tree-leaf:hover { background-color: #d0e8ff; }
  .folder-icon { 
    display: inline-block; 
    width: 12px; 
    margin-right: 3px;
    font-weight: bold;
  }
  .collapsed { display: none; }
</style>
</head>
<body>
<h1>Redis Subscriber 4</h1>

<div class="controls">
  <!-- KEB Protocol Section (optional) -->
  <div class="section keb-nodes">
    <label>KEB Node Discovery:</label>
    <button id="discover-nodes">Discover Nodes</button>
    <div id="discovered-list" style="margin-top: 10px; max-height: 200px; overflow-y: auto; border: 1px solid #ccc; padding: 5px; display: none;"></div>
    
    <label for="nodes" style="margin-top: 15px;">Selected Nodes (one per line):</label>
    <textarea id="nodes" placeholder="Click 'Discover Nodes' to find available nodes, then click to add from the list above"></textarea>
    <button id="subscribe-nodes">Subscribe Nodes</button>
    <button id="clear-nodes">Clear All Nodes</button>
  </div>
  
  <div class="status" id="status"></div>
</div>

<div class="messages-container">
  <div class="node-values">
    <div class="column-header">Subscribed Node Values</div>
    <div id="node-values-list"></div>
  </div>
  
  <div class="activity-log">
    <div class="column-header">Activity Log</div>
    <div id="messages"></div>
  </div>
</div>

<!-- Edit Value Modal -->
<div id="edit-modal" class="modal">
  <div class="modal-content">
    <div class="modal-header">Edit Node Value</div>
    <div class="modal-body">
      <input type="hidden" id="edit-request-id">
      
      <label class="modal-label">Node Name:</label>
      <input type="text" id="edit-node-name" class="modal-input" readonly>
      
      <label class="modal-label">New Value:</label>
      <input type="text" id="edit-new-value" class="modal-input" placeholder="Enter new value">
    </div>
    <div class="modal-footer">
      <button class="btn-secondary" id="cancel-edit">Cancel</button>
      <button class="btn-primary" id="save-edit">Save</button>
    </div>
  </div>
</div>

<script>
  const socket = io();
  const nodeValues = {}; // Track current values of subscribed nodes
  const nodeRequestIds = {}; // Track request IDs for each node
  const expandedFolders = new Set(); // Track which folders are expanded
  let lastRenderedNodes = ''; // Track when we need to rebuild the tree

  socket.on('redis-message', ({ channel, message }) => {
    // Update activity log (right column)
    const div = document.createElement('div');
    div.className = 'channel';
    div.textContent = `${channel} : ${message}`;
    document.getElementById('messages').prepend(div);
    
    // Update node values display (left column) if this is a subscribed node
    updateNodeValue(channel, message);
  });
  
  function updateNodeValue(channel, message) {
    // Check if this channel matches any subscribed nodes
    const nodesText = document.getElementById('nodes').value;
    const subscribedNodesList = nodesText.split('\n').map(n => n.trim()).filter(n => n.length > 0);
    
    if (subscribedNodesList.includes(channel)) {
      // Parse and extract value
      try {
        const data = JSON.parse(message);
        
        // Format 1: {"value": X} - simple value update
        if (data.value !== undefined) {
          nodeValues[channel] = data.value;
        }
        // Format 2: {"requestId":"...", "result":{nodeName: value}} - response with requestId
        else if (data.requestId && data.result) {
          nodeRequestIds[channel] = data.requestId;
          if (data.result[channel] !== undefined) {
            nodeValues[channel] = data.result[channel];
          }
        }
      } catch (e) {
        // If not JSON, just store the raw message
        nodeValues[channel] = message;
      }
      renderNodeValues();
    }
    
    // Also check if this is a UUID channel with requestId format
    try {
      const data = JSON.parse(message);
      if (data.requestId && data.result) {
        // Store requestId for all nodes in the result
        Object.keys(data.result).forEach(nodeName => {
          if (subscribedNodesList.includes(nodeName)) {
            nodeRequestIds[nodeName] = data.requestId;
            nodeValues[nodeName] = data.result[nodeName];
          }
        });
        renderNodeValues();
      }
    } catch (e) {
      // Not a valid JSON or UUID format, ignore
    }
  }
  
  function renderNodeValues() {
    const container = document.getElementById('node-values-list');
    const nodesText = document.getElementById('nodes').value;
    const subscribedNodesList = nodesText.split('\n').map(n => n.trim()).filter(n => n.length > 0);
    
    if (subscribedNodesList.length === 0) {
      container.innerHTML = '<div style="color: #999;">No nodes subscribed</div>';
      lastRenderedNodes = '';
      return;
    }
    
    // Only rebuild tree if the node list has changed
    if (lastRenderedNodes !== nodesText) {
      container.innerHTML = '';
      lastRenderedNodes = nodesText;
      
      // Build tree structure from subscribed nodes
      const tree = buildTree(subscribedNodesList);
      const treeContainer = document.createElement('div');
      treeContainer.className = 'tree-container';
      renderNodeValueTree(tree, treeContainer, '');
      container.appendChild(treeContainer);
    } else {
      // Just update the values without rebuilding the tree
      updateNodeValuesInTree();
    }
  }
  
  function updateNodeValuesInTree() {
    // Update all node values in the existing tree structure
    const container = document.getElementById('node-values-list');
    const nodesText = document.getElementById('nodes').value;
    const subscribedNodesList = nodesText.split('\n').map(n => n.trim()).filter(n => n.length > 0);
    
    subscribedNodesList.forEach(nodePath => {
      // Find the node item div for this node
      const nodeItems = container.querySelectorAll('.node-item');
      nodeItems.forEach(item => {
        const nameSpan = item.querySelector('.node-name');
        if (nameSpan && nameSpan.textContent === nodePath) {
          // Update value
          const valueSpan = item.querySelector('.node-value');
          if (valueSpan) {
            const displayValue = nodeValues[nodePath] !== undefined ? nodeValues[nodePath] : 'waiting for data...';
            valueSpan.textContent = `Value: ${displayValue}`;
          }
          
          // Update or add request ID
          let requestIdSpan = item.querySelector('[style*="font-size: 11px"]');
          if (nodeRequestIds[nodePath]) {
            if (requestIdSpan) {
              requestIdSpan.textContent = `Request ID: ${nodeRequestIds[nodePath]}`;
            } else {
              requestIdSpan = document.createElement('div');
              requestIdSpan.style.fontSize = '11px';
              requestIdSpan.style.color = '#666';
              requestIdSpan.style.marginTop = '3px';
              requestIdSpan.textContent = `Request ID: ${nodeRequestIds[nodePath]}`;
              const editBtn = item.querySelector('.edit-button');
              if (editBtn) {
                item.insertBefore(requestIdSpan, editBtn);
              } else {
                item.appendChild(requestIdSpan);
              }
            }
          }
          
          // Add or update edit button
          let editBtn = item.querySelector('.edit-button');
          if (nodeValues[nodePath] !== undefined && !editBtn) {
            editBtn = document.createElement('button');
            editBtn.className = 'edit-button';
            editBtn.textContent = 'Edit';
            editBtn.addEventListener('click', () => openEditModal(nodePath));
            item.appendChild(editBtn);
          }
        }
      });
    });
  }
  
  function renderNodeValueTree(tree, container, parentPath) {
    // Sort keys alphabetically
    const sortedKeys = Object.keys(tree).filter(key => !key.startsWith('_')).sort();
    
    sortedKeys.forEach(key => {
      const node = tree[key];
      const currentPath = parentPath ? `${parentPath}.${key}` : key;
      
      if (node._isLeaf) {
        // Leaf node - display value and edit button
        const nodeDiv = document.createElement('div');
        nodeDiv.className = 'node-item';
        nodeDiv.style.marginLeft = '0';
        
        const nameSpan = document.createElement('div');
        nameSpan.className = 'node-name';
        nameSpan.textContent = node._fullPath;
        
        const valueSpan = document.createElement('div');
        valueSpan.className = 'node-value';
        const displayValue = nodeValues[node._fullPath] !== undefined ? nodeValues[node._fullPath] : 'waiting for data...';
        valueSpan.textContent = `Value: ${displayValue}`;
        
        nodeDiv.appendChild(nameSpan);
        nodeDiv.appendChild(valueSpan);
        
        // Show request ID if available
        if (nodeRequestIds[node._fullPath]) {
          const requestIdSpan = document.createElement('div');
          requestIdSpan.style.fontSize = '11px';
          requestIdSpan.style.color = '#666';
          requestIdSpan.style.marginTop = '3px';
          requestIdSpan.textContent = `Request ID: ${nodeRequestIds[node._fullPath]}`;
          nodeDiv.appendChild(requestIdSpan);
        }
        
        // Add edit button if we have data for this node
        if (nodeValues[node._fullPath] !== undefined) {
          const editBtn = document.createElement('button');
          editBtn.className = 'edit-button';
          editBtn.textContent = 'Edit';
          editBtn.addEventListener('click', () => openEditModal(node._fullPath));
          nodeDiv.appendChild(editBtn);
        }
        
        container.appendChild(nodeDiv);
      } else {
        // Folder node
        const folderDiv = document.createElement('div');
        folderDiv.className = 'tree-folder';
        folderDiv.style.marginBottom = '5px';
        
        const folderLabel = document.createElement('div');
        folderLabel.className = 'tree-folder-label';
        
        const iconSpan = document.createElement('span');
        iconSpan.className = 'folder-icon';
        iconSpan.textContent = '▶';
        
        const nameSpan = document.createElement('span');
        nameSpan.textContent = key;
        nameSpan.style.fontWeight = 'bold';
        
        folderLabel.appendChild(iconSpan);
        folderLabel.appendChild(nameSpan);
        
        const childContainer = document.createElement('div');
        childContainer.className = 'tree-item collapsed';
        
        // Check if this folder should be expanded
        if (expandedFolders.has(currentPath)) {
          childContainer.classList.remove('collapsed');
          iconSpan.textContent = '▼';
        }
        
        // Click folder label to toggle expand/collapse
        folderLabel.addEventListener('click', (e) => {
          e.stopPropagation();
          const isCollapsed = childContainer.classList.contains('collapsed');
          childContainer.classList.toggle('collapsed');
          iconSpan.textContent = isCollapsed ? '▼' : '▶';
          
          // Track expanded/collapsed state
          if (isCollapsed) {
            expandedFolders.add(currentPath);
          } else {
            expandedFolders.delete(currentPath);
          }
        });
        
        folderDiv.appendChild(folderLabel);
        container.appendChild(folderDiv);
        renderNodeValueTree(node, childContainer, currentPath);
        container.appendChild(childContainer);
      }
    });
  }

  socket.on('subscription-status', ({ pattern, status }) => {
    document.getElementById('status').textContent = `Status: ${status}`;
  });

  // Request current state on load
  socket.on('connect', () => {
    socket.emit('get-current-pattern');
  });

  // ============================================================================
  // EDIT MODAL FUNCTIONALITY
  // ============================================================================
  function generateUUID() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
      const r = Math.random() * 16 | 0;
      const v = c == 'x' ? r : (r & 0x3 | 0x8);
      return v.toString(16);
    });
  }
  
  function openEditModal(nodeName) {
    // Use existing request ID or generate a new one
    const requestId = nodeRequestIds[nodeName] || generateUUID();
    const currentValue = nodeValues[nodeName];
    
    document.getElementById('edit-request-id').value = requestId;
    document.getElementById('edit-node-name').value = nodeName;
    document.getElementById('edit-new-value').value = currentValue;
    
    document.getElementById('edit-modal').style.display = 'block';
  }
  
  document.getElementById('cancel-edit').addEventListener('click', () => {
    document.getElementById('edit-modal').style.display = 'none';
  });
  
  document.getElementById('save-edit').addEventListener('click', () => {
    const requestId = document.getElementById('edit-request-id').value;
    const nodeName = document.getElementById('edit-node-name').value;
    const newValueStr = document.getElementById('edit-new-value').value;
    
    // Parse the new value (try to detect if it's a number)
    let newValue = newValueStr;
    if (!isNaN(newValueStr) && newValueStr.trim() !== '') {
      newValue = Number(newValueStr);
    }
    
    // Construct the $kebSet message
    const kebSetMessage = {
      requestId: requestId,
      args: {
        [nodeName]: newValue
      },
      responseTopic: requestId
    };
    
    // Emit to server to publish to Redis
    socket.emit('publish-keb-set', kebSetMessage);
    
    // Log to activity
    const div = document.createElement('div');
    div.className = 'channel';
    div.style.color = '#ff6600';
    div.textContent = `$kebSet : ${JSON.stringify(kebSetMessage)}`;
    document.getElementById('messages').prepend(div);
    
    // Close modal
    document.getElementById('edit-modal').style.display = 'none';
  });
  
  // Close modal when clicking outside
  window.addEventListener('click', (event) => {
    const modal = document.getElementById('edit-modal');
    if (event.target === modal) {
      modal.style.display = 'none';
    }
  });
  
  // ============================================================================
  // OPTIONAL: KEB Protocol Client Code
  // ============================================================================
  let kebProtocolEnabled = false;
  let discoveredNodes = [];

  socket.on('keb-protocol-enabled', (enabled) => {
    kebProtocolEnabled = enabled;
    // Show/hide KEB section based on server support
    const kebSection = document.querySelector('.section.keb-nodes');
    if (kebSection) {
      kebSection.style.display = enabled ? 'block' : 'none';
    }
  });

  // Handle node discovery
  document.getElementById('discover-nodes').addEventListener('click', () => {
    if (!kebProtocolEnabled) return;
    socket.emit('discover-nodes');
  });

  socket.on('discovered-nodes', (nodes) => {
    discoveredNodes = nodes;
    const listDiv = document.getElementById('discovered-list');
    
    if (nodes.length === 0) {
      listDiv.style.display = 'none';
      return;
    }
    
    listDiv.style.display = 'block';
    listDiv.innerHTML = '<div style="font-weight: bold; margin-bottom: 5px;">Click nodes to add (click "+ All" on folders to add all):</div>';
    
    // Build tree structure
    const tree = buildTree(nodes);
    const treeContainer = document.createElement('div');
    treeContainer.className = 'tree-container';
    renderTree(tree, treeContainer, '');
    listDiv.appendChild(treeContainer);
  });
  
  function buildTree(nodes) {
    const tree = {};
    
    nodes.forEach(node => {
      const parts = node.split('.');
      let current = tree;
      
      parts.forEach((part, index) => {
        if (!current[part]) {
          current[part] = {
            _isLeaf: index === parts.length - 1,
            _fullPath: index === parts.length - 1 ? node : null
          };
        }
        if (index < parts.length - 1) {
          current = current[part];
        }
      });
    });
    
    return tree;
  }
  
  function renderTree(tree, container, parentPath) {
    // Sort keys alphabetically
    const sortedKeys = Object.keys(tree).filter(key => !key.startsWith('_')).sort();
    
    sortedKeys.forEach(key => {
      
      const node = tree[key];
      const currentPath = parentPath ? `${parentPath}.${key}` : key;
      
      if (node._isLeaf) {
        // Leaf node - single click to add
        const leafDiv = document.createElement('div');
        leafDiv.className = 'tree-leaf';
        leafDiv.textContent = key;
        leafDiv.title = node._fullPath;
        leafDiv.addEventListener('click', () => {
          addNodeToSubscription(node._fullPath);
        });
        container.appendChild(leafDiv);
      } else {
        // Folder node
        const folderDiv = document.createElement('div');
        folderDiv.className = 'tree-folder';
        
        const folderLabel = document.createElement('div');
        folderLabel.className = 'tree-folder-label';
        
        const iconSpan = document.createElement('span');
        iconSpan.className = 'folder-icon';
        iconSpan.textContent = '▶';
        
        const nameSpan = document.createElement('span');
        nameSpan.textContent = key;
        
        folderLabel.appendChild(iconSpan);
        folderLabel.appendChild(nameSpan);
        
        // Add button to subscribe all nodes in folder
        const addBtn = document.createElement('button');
        addBtn.className = 'tree-folder-add-btn';
        addBtn.textContent = '+ All';
        addBtn.title = 'Add all nodes in this folder';
        addBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          const leafNodes = getAllLeafNodes(node);
          leafNodes.forEach(leafPath => addNodeToSubscription(leafPath));
        });
        
        const childContainer = document.createElement('div');
        childContainer.className = 'tree-item collapsed';
        
        // Click folder label to toggle expand/collapse
        folderLabel.addEventListener('click', (e) => {
          e.stopPropagation();
          const isCollapsed = childContainer.classList.contains('collapsed');
          childContainer.classList.toggle('collapsed');
          iconSpan.textContent = isCollapsed ? '▼' : '▶';
        });
        
        folderDiv.appendChild(folderLabel);
        folderDiv.appendChild(addBtn);
        container.appendChild(folderDiv);
        renderTree(node, childContainer, currentPath);
        container.appendChild(childContainer);
      }
    });
  }
  
  function getAllLeafNodes(tree) {
    const leaves = [];
    
    function traverse(obj) {
      Object.keys(obj).forEach(key => {
        if (key === '_fullPath' && obj[key]) {
          leaves.push(obj[key]);
        } else if (typeof obj[key] === 'object' && !key.startsWith('_')) {
          traverse(obj[key]);
        }
      });
    }
    
    traverse(tree);
    return leaves;
  }
  
  function addNodeToSubscription(nodePath) {
    const currentNodes = document.getElementById('nodes').value;
    const nodeList = currentNodes ? currentNodes.split('\n').map(n => n.trim()).filter(n => n) : [];
    if (!nodeList.includes(nodePath)) {
      nodeList.push(nodePath);
      nodeList.sort(); // Alphabetize
      document.getElementById('nodes').value = nodeList.join('\n');
    }
  }

  // KEB node subscription
  document.getElementById('subscribe-nodes').addEventListener('click', () => {
    if (!kebProtocolEnabled) return;
    const nodesText = document.getElementById('nodes').value;
    const nodes = nodesText.split('\n').map(n => n.trim()).filter(n => n.length > 0);
    if (nodes.length > 0) {
      socket.emit('subscribe-nodes', nodes);
      // Clear old values and re-render
      Object.keys(nodeValues).forEach(key => delete nodeValues[key]);
      renderNodeValues();
    }
  });

  socket.on('subscribed-nodes', (nodes) => {
    if (nodes.length > 0) {
      nodes.sort(); // Alphabetize
      document.getElementById('nodes').value = nodes.join('\n');
      renderNodeValues();
    }
  });
  
  // Clear nodes button
  document.getElementById('clear-nodes').addEventListener('click', () => {
    document.getElementById('nodes').value = '';
    Object.keys(nodeValues).forEach(key => delete nodeValues[key]);
    renderNodeValues();
  });
  // ============================================================================
  // END KEB PROTOCOL CLIENT CODE
  // ============================================================================
</script>
</body>
</html>