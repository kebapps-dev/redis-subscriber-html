<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Redis Subscriber 4</title>
<script src="/socket.io/socket.io.js"></script>
<style>
  body { font-family: monospace; padding: 20px; }
  .channel { margin-bottom: 10px; }
  .controls { margin-bottom: 20px; padding: 15px; border: 1px solid #ccc; }
  input { padding: 5px; font-family: monospace; width: 300px; }
  textarea { padding: 5px; font-family: monospace; width: 100%; min-height: 100px; }
  button { padding: 5px 15px; cursor: pointer; margin-right: 5px; }
  .status { margin-top: 10px; color: green; }
  .section { margin-bottom: 15px; }
  label { display: block; margin-bottom: 5px; font-weight: bold; }
  
  /* Two-column layout */
  .messages-container { display: flex; gap: 20px; }
  .node-values { 
    flex: 1; 
    border: 1px solid #ccc; 
    padding: 10px; 
    max-height: 600px; 
    overflow-y: auto;
  }
  .activity-log { 
    flex: 1; 
    border: 1px solid #ccc; 
    padding: 10px; 
    max-height: 600px; 
    overflow-y: auto;
  }
  .column-header { 
    font-weight: bold; 
    font-size: 16px; 
    margin-bottom: 10px; 
    padding-bottom: 5px; 
    border-bottom: 2px solid #333;
  }
  .node-item {
    margin-bottom: 8px;
    padding: 5px;
    background: #f5f5f5;
    border-left: 3px solid #4CAF50;
  }
  .node-name {
    font-weight: bold;
    color: #333;
  }
  .node-value {
    color: #0066cc;
    margin-left: 10px;
  }
  
  /* Tree view styles */
  .tree-container { font-family: monospace; }
  .tree-item { margin-left: 15px; }
  .tree-folder { 
    cursor: pointer; 
    padding: 3px; 
    user-select: none;
  }
  .tree-folder:hover { background-color: #e0e0e0; }
  .tree-leaf { 
    cursor: pointer; 
    padding: 3px; 
    color: #0066cc;
  }
  .tree-leaf:hover { background-color: #d0e8ff; }
  .folder-icon { 
    display: inline-block; 
    width: 12px; 
    margin-right: 3px;
    font-weight: bold;
  }
  .collapsed { display: none; }
</style>
</head>
<body>
<h1>Redis Subscriber 4</h1>

<div class="controls">
  <div class="section">
    <label for="pattern">Subscription Pattern:</label>
    <input type="text" id="pattern" value="*" placeholder="e.g., c6c3_228.* or *">
    <button id="subscribe-pattern">Subscribe Pattern</button>
  </div>
  
  <!-- KEB Protocol Section (optional) -->
  <div class="section keb-nodes">
    <label>KEB Node Discovery:</label>
    <button id="discover-nodes">Discover Nodes</button>
    <div id="discovered-list" style="margin-top: 10px; max-height: 200px; overflow-y: auto; border: 1px solid #ccc; padding: 5px; display: none;"></div>
    
    <label for="nodes" style="margin-top: 15px;">Selected Nodes (one per line):</label>
    <textarea id="nodes" placeholder="Click 'Discover Nodes' to find available nodes, then select from the list above"></textarea>
    <button id="subscribe-nodes">Subscribe Nodes</button>
  </div>
  
  <div class="status" id="status"></div>
</div>

<div class="messages-container">
  <div class="node-values">
    <div class="column-header">Subscribed Node Values</div>
    <div id="node-values-list"></div>
  </div>
  
  <div class="activity-log">
    <div class="column-header">Activity Log</div>
    <div id="messages"></div>
  </div>
</div>

<script>
  const socket = io();
  const nodeValues = {}; // Track current values of subscribed nodes

  socket.on('redis-message', ({ channel, message }) => {
    // Update activity log (right column)
    const div = document.createElement('div');
    div.className = 'channel';
    div.textContent = `${channel} : ${message}`;
    document.getElementById('messages').prepend(div);
    
    // Update node values display (left column) if this is a subscribed node
    updateNodeValue(channel, message);
  });
  
  function updateNodeValue(channel, message) {
    // Check if this channel matches any subscribed nodes
    const nodesText = document.getElementById('nodes').value;
    const subscribedNodesList = nodesText.split('\n').map(n => n.trim()).filter(n => n.length > 0);
    
    if (subscribedNodesList.includes(channel)) {
      nodeValues[channel] = message;
      renderNodeValues();
    }
  }
  
  function renderNodeValues() {
    const container = document.getElementById('node-values-list');
    container.innerHTML = '';
    
    const nodesText = document.getElementById('nodes').value;
    const subscribedNodesList = nodesText.split('\n').map(n => n.trim()).filter(n => n.length > 0);
    
    if (subscribedNodesList.length === 0) {
      container.innerHTML = '<div style="color: #999;">No nodes subscribed</div>';
      return;
    }
    
    subscribedNodesList.forEach(node => {
      const nodeDiv = document.createElement('div');
      nodeDiv.className = 'node-item';
      
      const nameSpan = document.createElement('div');
      nameSpan.className = 'node-name';
      nameSpan.textContent = node;
      
      const valueSpan = document.createElement('div');
      valueSpan.className = 'node-value';
      valueSpan.textContent = nodeValues[node] || 'waiting for data...';
      
      nodeDiv.appendChild(nameSpan);
      nodeDiv.appendChild(valueSpan);
      container.appendChild(nodeDiv);
    });
  }

  socket.on('subscription-status', ({ pattern, status }) => {
    document.getElementById('status').textContent = `Status: ${status} - Pattern: ${pattern}`;
  });

  // Pattern subscription
  document.getElementById('subscribe-pattern').addEventListener('click', () => {
    const pattern = document.getElementById('pattern').value || '*';
    socket.emit('change-pattern', pattern);
  });

  // Request current state on load
  socket.on('connect', () => {
    socket.emit('get-current-pattern');
  });

  socket.on('current-pattern', (pattern) => {
    document.getElementById('pattern').value = pattern;
    document.getElementById('status').textContent = `Status: Subscribed - Pattern: ${pattern}`;
  });

  // ============================================================================
  // OPTIONAL: KEB Protocol Client Code
  // ============================================================================
  let kebProtocolEnabled = false;
  let discoveredNodes = [];

  socket.on('keb-protocol-enabled', (enabled) => {
    kebProtocolEnabled = enabled;
    // Show/hide KEB section based on server support
    const kebSection = document.querySelector('.section.keb-nodes');
    if (kebSection) {
      kebSection.style.display = enabled ? 'block' : 'none';
    }
  });

  // Handle node discovery
  document.getElementById('discover-nodes').addEventListener('click', () => {
    if (!kebProtocolEnabled) return;
    socket.emit('discover-nodes');
  });

  socket.on('discovered-nodes', (nodes) => {
    discoveredNodes = nodes;
    const listDiv = document.getElementById('discovered-list');
    
    if (nodes.length === 0) {
      listDiv.style.display = 'none';
      return;
    }
    
    listDiv.style.display = 'block';
    listDiv.innerHTML = '<div style="font-weight: bold; margin-bottom: 5px;">Click nodes to add (double-click folders to add all):</div>';
    
    // Build tree structure
    const tree = buildTree(nodes);
    const treeContainer = document.createElement('div');
    treeContainer.className = 'tree-container';
    renderTree(tree, treeContainer, '');
    listDiv.appendChild(treeContainer);
  });
  
  function buildTree(nodes) {
    const tree = {};
    
    nodes.forEach(node => {
      const parts = node.split('.');
      let current = tree;
      
      parts.forEach((part, index) => {
        if (!current[part]) {
          current[part] = {
            _isLeaf: index === parts.length - 1,
            _fullPath: index === parts.length - 1 ? node : null
          };
        }
        if (index < parts.length - 1) {
          current = current[part];
        }
      });
    });
    
    return tree;
  }
  
  function renderTree(tree, container, parentPath) {
    Object.keys(tree).forEach(key => {
      if (key.startsWith('_')) return; // Skip metadata keys
      
      const node = tree[key];
      const currentPath = parentPath ? `${parentPath}.${key}` : key;
      
      if (node._isLeaf) {
        // Leaf node - single click to add
        const leafDiv = document.createElement('div');
        leafDiv.className = 'tree-leaf';
        leafDiv.textContent = key;
        leafDiv.title = node._fullPath;
        leafDiv.addEventListener('click', () => {
          addNodeToSubscription(node._fullPath);
        });
        container.appendChild(leafDiv);
      } else {
        // Folder node
        const folderDiv = document.createElement('div');
        folderDiv.className = 'tree-folder';
        
        const iconSpan = document.createElement('span');
        iconSpan.className = 'folder-icon';
        iconSpan.textContent = '▶';
        
        const nameSpan = document.createElement('span');
        nameSpan.textContent = key;
        
        folderDiv.appendChild(iconSpan);
        folderDiv.appendChild(nameSpan);
        
        const childContainer = document.createElement('div');
        childContainer.className = 'tree-item collapsed';
        
        // Single click to toggle expand/collapse
        folderDiv.addEventListener('click', (e) => {
          e.stopPropagation();
          const isCollapsed = childContainer.classList.contains('collapsed');
          childContainer.classList.toggle('collapsed');
          iconSpan.textContent = isCollapsed ? '▼' : '▶';
        });
        
        // Double click to add all leaf nodes in this folder
        folderDiv.addEventListener('dblclick', (e) => {
          e.stopPropagation();
          const leafNodes = getAllLeafNodes(node);
          leafNodes.forEach(leafPath => addNodeToSubscription(leafPath));
        });
        
        container.appendChild(folderDiv);
        renderTree(node, childContainer, currentPath);
        container.appendChild(childContainer);
      }
    });
  }
  
  function getAllLeafNodes(tree) {
    const leaves = [];
    
    function traverse(obj) {
      Object.keys(obj).forEach(key => {
        if (key === '_fullPath' && obj[key]) {
          leaves.push(obj[key]);
        } else if (typeof obj[key] === 'object' && !key.startsWith('_')) {
          traverse(obj[key]);
        }
      });
    }
    
    traverse(tree);
    return leaves;
  }
  
  function addNodeToSubscription(nodePath) {
    const currentNodes = document.getElementById('nodes').value;
    const nodeList = currentNodes ? currentNodes.split('\n') : [];
    if (!nodeList.includes(nodePath)) {
      nodeList.push(nodePath);
      document.getElementById('nodes').value = nodeList.join('\n');
    }
  }

  // KEB node subscription
  document.getElementById('subscribe-nodes').addEventListener('click', () => {
    if (!kebProtocolEnabled) return;
    const nodesText = document.getElementById('nodes').value;
    const nodes = nodesText.split('\n').map(n => n.trim()).filter(n => n.length > 0);
    if (nodes.length > 0) {
      socket.emit('subscribe-nodes', nodes);
      // Clear old values and re-render
      Object.keys(nodeValues).forEach(key => delete nodeValues[key]);
      renderNodeValues();
    }
  });

  socket.on('subscribed-nodes', (nodes) => {
    if (nodes.length > 0) {
      document.getElementById('nodes').value = nodes.join('\n');
      renderNodeValues();
    }
  });
  // ============================================================================
  // END KEB PROTOCOL CLIENT CODE
  // ============================================================================
</script>
</body>
</html>